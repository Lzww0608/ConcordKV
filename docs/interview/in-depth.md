1.  **关于LSM-Tree的“放大”问题：**
    你的项目提到了通过分层压缩策略来有效控制“**读放大（Read Amplification）**”、“**写放大（Write Amplification）**”和“**空间放大（Space Amplification）**”。
    *   你能否详细解释这三个“放大”问题具体是什么？
    *   业界主流的压缩策略有Leveled Compaction和Tiered Compaction，你的“分层压缩”更接近哪一种？请说明你的策略是如何在这三个“放大”问题之间进行权衡（Trade-off）的。

2.  **关于高级缓存算法：**
    你实现了**ARC**和**TinyLFU**这两种更现代的缓存算法。
    *   请比较一下它们与传统LRU/LFU的核心区别，以及它们分别试图解决LRU/LFU的什么固有缺陷？
    *   在你的ConcordKV框架下，你会为哪种工作负载（Workload）推荐使用ARC，又会为哪种推荐TinyLFU？请说明理由。

3.  **关于哈希引擎的细节：**
    在你的哈希表引擎中，你提到了使用“链地址法（链表与红黑树）”解决哈希冲突。这通常被称为 `separate chaining with treeing`。
    *   请问，在什么情况下链表会转换成红黑树？这个转换阈值（比如8个节点）是如何决定的？
    *   这个设计在C++实现上有什么需要特别注意的细节？（例如内存管理、迭代器失效、或者在析构时如何正确释放两种不同类型的节点）

4.  **关于系统组件交互：**
    你的系统设计中，缓存层和存储引擎层是解耦的。请考虑一个场景：当LSM-Tree发生**Compaction**时，SSTable中的数据块被重写或合并到了新的文件中。此时，你的缓存子系统（比如一个Block Cache）中可能存在指向旧SSTable数据块的缓存条目。你是如何处理这种**缓存失效（Cache Invalidation）**问题的？请描述你的设计方案。