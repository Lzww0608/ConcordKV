# ConcordKV Common 架构设计文档

## 总体架构

ConcordKV Common 模块采用分层模块化设计，为分布式键值存储系统提供基础支撑服务。

```
┌─────────────────────────────────────────────────────────┐
│                    ConcordKV Server                    │
├─────────────────────────────────────────────────────────┤
│                   Common 模块                          │
├──────────────┬──────────────┬──────────────┬───────────┤
│   配置管理   │   通用工具   │   监控指标   │  测试工具 │
│   config/    │    util/     │   metrics/   │ testing/  │
└──────────────┴──────────────┴──────────────┴───────────┘
```

## 模块设计原则

### 1. 低耦合高内聚
- 各模块功能明确，边界清晰
- 模块间通过标准化接口交互
- 减少不必要的依赖关系

### 2. 线程安全
- 所有对外接口都考虑多线程环境
- 使用适当的同步机制保证数据一致性
- 避免死锁和竞态条件

### 3. 高性能
- 关键路径优化，减少不必要的开销
- 内存池和对象复用
- 缓存友好的数据结构

### 4. 可测试性
- 提供完整的测试工具支持
- 支持模拟和故障注入
- 详细的性能基准测试

## 配置管理模块架构

### 设计目标
- 统一的配置访问接口
- 支持多种配置源和格式
- 动态配置更新能力
- 类型安全的配置访问

### 核心组件

```
config/
├── config.h/.c        # 核心配置管理
├── parser.h/.c        # 配置解析引擎
└── [配置源适配器]      # 文件、环境变量、网络等
```

### 架构层次

```
┌─────────────────────────────────────┐
│            应用层接口               │  ← 类型安全的get/set接口
├─────────────────────────────────────┤
│            配置管理核心             │  ← 统一配置模型，变更通知
├─────────────────────────────────────┤
│            解析引擎                 │  ← YAML/JSON/INI解析器
├─────────────────────────────────────┤
│           配置源适配器              │  ← 文件、环境变量、网络
└─────────────────────────────────────┘
```

### 关键设计决策

1. **统一配置模型**：使用树状结构表示所有配置
2. **延迟解析**：配置值在首次访问时才进行类型转换
3. **变更通知**：支持配置热更新，通过回调通知变更
4. **默认值支持**：所有get操作都支持默认值

## 通用工具模块架构

### 设计目标
- 提供常用的工具函数
- 跨平台兼容性
- 高性能实现
- 简洁易用的API

### 模块结构

```
util/
├── util.h/.c          # 基础工具函数
├── log.h/.c           # 日志系统
├── network.h/.c       # 网络工具
├── network_io.c       # 网络IO扩展
├── timer.h/.c         # 定时器系统
├── crypt.h/.c         # 加密工具
└── Makefile           # 编译配置
```

### 功能分层

```
┌─────────────────────────────────────────┐
│              应用层工具                 │  ← HTTP客户端、定时器等
├─────────────────────────────────────────┤
│              系统抽象层                 │  ← 网络、文件、时间操作
├─────────────────────────────────────────┤
│              基础工具层                 │  ← 字符串、哈希、加密
└─────────────────────────────────────────┘
```

### 关键特性

1. **内存管理**：提供内存池和对象复用机制
2. **错误处理**：统一的错误码和错误信息
3. **平台适配**：屏蔽操作系统差异
4. **性能优化**：关键函数使用优化算法

## 监控指标模块架构

### 设计目标
- 低延迟的指标收集
- 丰富的指标类型支持
- 标准化的指标输出
- 可扩展的存储后端

### 核心架构

```
metrics/
├── metrics.h/.c       # 核心指标引擎
├── metrics_format.c   # 格式化输出
├── metrics_demo.c     # 示例程序
└── Makefile           # 编译配置
```

### 系统架构

```
┌─────────────────────────────────────────────────────────┐
│                 应用代码                                │
├─────────────────────────────────────────────────────────┤
│                指标API层                                │  ← Counter/Gauge/Histogram/Meter
├─────────────────────────────────────────────────────────┤
│                指标存储层                               │  ← 哈希表 + 原子操作
├─────────────────────────────────────────────────────────┤
│                输出格式层                               │  ← Text/JSON/Prometheus
├─────────────────────────────────────────────────────────┤
│                传输层                                   │  ← HTTP服务器、文件输出
└─────────────────────────────────────────────────────────┘
```

### 指标类型设计

1. **Counter (计数器)**
   - 单调递增的64位整数
   - 原子操作保证线程安全
   - 适合统计请求数、错误数等

2. **Gauge (仪表盘)**
   - 可增可减的浮点数
   - 表示当前状态值
   - 适合内存使用、连接数等

3. **Histogram (直方图)**
   - 记录数值分布
   - 支持百分位数计算
   - 适合延迟、大小分布等

4. **Meter (计量表)**
   - 记录事件发生速率
   - 指数移动平均算法
   - 提供1分钟、5分钟、15分钟速率

### 存储优化

- **哈希表存储**：O(1)查找性能
- **无锁设计**：使用原子操作替代锁
- **内存预分配**：减少动态分配开销
- **缓存友好**：数据结构对齐优化

## 测试工具模块架构

### 设计目标
- 全面的测试能力覆盖
- 真实的负载模拟
- 灵活的故障注入
- 详细的性能分析

### 模块组成

```
testing/
├── testing.h          # 统一接口定义
├── mock_client.c      # 模拟客户端
├── fault_inject.c     # 故障注入
├── benchmark.c        # 性能基准测试
├── test_data.c        # 测试数据生成
├── testing_demo.c     # 示例程序
└── Makefile           # 编译配置
```

### 测试框架架构

```
┌─────────────────────────────────────────────────────────┐
│                测试场景编排                             │  ← 测试脚本、测试套件
├─────────────────────────────────────────────────────────┤
│          测试工具层                                     │
├──────────────┬──────────────┬──────────────┬───────────┤
│  模拟客户端  │  故障注入    │  基准测试    │ 数据生成  │
├──────────────┴──────────────┴──────────────┴───────────┤
│                基础设施层                               │  ← 统计、报告、数据存储
└─────────────────────────────────────────────────────────┘
```

### 模拟客户端设计

```
┌─────────────────────────────────────┐
│           测试控制器                │  ← 配置管理、生命周期控制
├─────────────────────────────────────┤
│           客户端管理器              │  ← 线程池、负载均衡
├─────────────────────────────────────┤
│           协议适配器                │  ← HTTP/TCP/自定义协议
├─────────────────────────────────────┤
│           统计收集器                │  ← 延迟、吞吐量、错误率
└─────────────────────────────────────┘
```

### 故障注入设计

支持多种故障类型：
- **网络故障**：延迟、丢包、连接重置
- **系统故障**：CPU尖峰、内存泄漏、磁盘满
- **应用故障**：超时、异常、资源耗尽

故障注入器特性：
- **概率控制**：按概率触发故障
- **时间控制**：设置故障持续时间
- **目标控制**：精确控制故障范围
- **严重程度**：分级的故障强度

### 基准测试设计

```
┌─────────────────────────────────────┐
│           测试编排器                │  ← 测试计划、执行控制
├─────────────────────────────────────┤
│           操作记录器                │  ← 延迟记录、成功率统计
├─────────────────────────────────────┤
│           统计分析器                │  ← 百分位数、分布分析
├─────────────────────────────────────┤
│           报告生成器                │  ← 图表、表格、摘要
└─────────────────────────────────────┘
```

## 跨模块集成

### 依赖关系

```
testing ←─── metrics ←─── util
   ↑                        ↑
   └─────── config ─────────┘
```

- `util` 是最底层模块，被其他模块依赖
- `config` 依赖 `util` 的基础功能
- `metrics` 依赖 `util` 的网络和时间功能
- `testing` 依赖所有其他模块

### 接口约定

1. **错误处理**：统一返回-1表示错误，0表示成功
2. **内存管理**：调用者负责释放返回的动态内存
3. **线程安全**：所有公共接口都是线程安全的
4. **命名约定**：使用 `concord_模块_功能` 前缀

### 初始化顺序

```c
// 推荐的初始化顺序
int init_common_modules() {
    // 1. 初始化基础工具
    // util模块通常不需要显式初始化
    
    // 2. 初始化配置管理
    // 配置通常在应用启动时加载
    
    // 3. 初始化监控指标
    // 创建指标仓库和指标
    
    // 4. 初始化测试工具（仅测试环境）
    if (is_test_environment()) {
        concord_testing_init();
    }
    
    return 0;
}
```

## 性能优化策略

### 内存优化
- **对象池**：复用频繁创建的对象
- **内存对齐**：优化缓存访问模式
- **预分配**：避免运行时动态分配

### 并发优化
- **无锁数据结构**：使用原子操作替代锁
- **读写分离**：读多写少场景的优化
- **线程局部存储**：减少竞争

### 算法优化
- **哈希算法**：选择高性能的哈希函数
- **排序算法**：针对特定场景优化
- **压缩算法**：平衡压缩率和性能

## 错误处理和恢复

### 错误分类
1. **系统错误**：内存不足、文件不存在等
2. **配置错误**：参数无效、格式错误等
3. **网络错误**：连接失败、超时等
4. **业务错误**：逻辑错误、状态不一致等

### 恢复策略
- **优雅降级**：功能受限但不崩溃
- **自动重试**：临时性错误的重试机制
- **降级处理**：使用默认值或缓存数据
- **错误上报**：记录详细错误信息

## 扩展性设计

### 插件架构
- **配置源插件**：支持新的配置来源
- **指标输出插件**：支持新的输出格式
- **测试协议插件**：支持新的测试协议

### 接口抽象
- **统一接口**：抽象化的操作接口
- **工厂模式**：动态创建实现对象
- **注册机制**：运行时注册新功能

这种架构设计确保了 ConcordKV Common 模块的可维护性、可扩展性和高性能，为分布式键值存储系统提供了坚实的基础支撑。 